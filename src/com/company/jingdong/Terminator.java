package com.company.jingdong;

import java.util.Scanner;

/**
 * 收到情报，有批新造的机器人要运输到前线。小C将去破坏机器人的运输。小C将激光炮放置在公路的一旁，等运输车经过的时候发射
 * （假设激光炮一定可以射穿车辆）。由于能源有限，激光炮只能发射两次。可以认为激光炮放在坐标轴的原点处，并向y轴正方向发射。
 * 每辆运输车可以看作是一个矩形，起始的x轴坐标为Xi,所有的车均位于第一象限，长度为Li,速度为1，朝x轴负方向运动。即经过t时间后，
 * 该车车头的x坐标为Xi-t，车尾坐标为Xi-t+Li。只要打中车的任何一个部分就算击中。 请你算算，他在哪两个时刻发射，才能摧毁最多的运输车。
 * 
 * 输入
 * 
 * 第一行一个正整数 n ( 2≤N≤200 )，表示运输个的数量。 接下来n行，每行两个整数X和L(1≤X、L≤109)，表示一辆车的x轴坐标和长度。
 * 样例输入
 * 
 * 4
 * 
 * 2 2
 * 
 * 3 1
 * 
 * 5 2
 * 
 * 7 3
 * 
 * 输出
 * 
 * 输出最多可以摧毁的运输车数量。
 * 
 * 题解：运输车相对位置不变，可以看成运输车不动，激光炮动，枚举放激光炮的地方。
 * 如果直接枚举位置的坐标，计算量太大，可以只枚举激光炮放在某两个车头或车尾的坐标处（此处使用车头）
 * 
 * 枚举所有可能的2个车头位置即可覆盖所有的情况，因为用扫描线从左向右扫过所有车辆，
 * 
 * 穿过车辆的个数的变化位置一定是发生在某车的车头或车尾， 车尾导致个数变小，车头导致个数变大。
 * 
 * 因此枚举所有可能的车头或车尾位置即可。
 * 
 * @author XIAO
 *
 */
public class Terminator {

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		while (in.hasNext()) {
			int n = in.nextInt();
			int[] ls = new int[n];// 所有运输车车头坐标
			int[] le = new int[n];// 所有运输车的车尾坐标
			for (int i = 0; i < n; i++) {
				ls[i] = in.nextInt();
				le[i] = ls[i] + in.nextInt();
			}

			int max = 0;// 最大摧毁数量
			// 两层循环枚举两发炮弹在某两辆车头发射的所有情况
			// 两枚炮弹在某两个车车头情况
			// 枚举两个车头位置ls[i]和ls[j]作为发射时刻，并计数可以摧毁的车的数量
			for (int i = 0; i < n; i++) {// 第一个发射时刻在第一个车头位置
				for (int j = i + 1; j < n; j++) {// 第二个发射时刻在第二个车头位置
					int temp = 0;
					// 循环判断每辆车是否能被炮弹命中，即（车头坐标<=激光炮坐标&&车尾坐标>=激光炮坐标）
					for (int k = 0; k < n; k++) {// 对车进行循环
						if ((ls[k] <= ls[i] && le[k] >= ls[i]) || (ls[k] <= ls[j] && le[k] >= ls[j])) {
							temp++;
						}
					}
					if (temp > max)
						max = temp;
				}
			}
			System.out.println(max);
		}
		in.close();
	}
}
